## 网关逻辑梳理

### gwrcv     进程数从lcore_mask中获取
1、dpdk主进程和多个从进程，负责读写网卡
g_fd_zones[core_id][fd]   公网fd二位数组
hash[idx]                 已使用的idx,确保连接不会冲突，(fd是可重用的，断开重连fd会是同一个，直接使用fd会把上一个连接的数据发送到新的连接中，因此用自增idx代替)
接收->接收到连接->计算一个idx->填充cli_info->发送到cliprc
发送->循环pop客户端写队列->根据fdopx选择发送数据还是关闭连接

### cliprc    线程数对应gwrcv的进程数
上行->cliprc->websocket解码->handleshake->authorized->fd的idx add进hash[idx]，以及一系列hash表的初始化->开始正常收发数据->上行透传->bwserver
下行->入客户端的写队列(ping的响应，关闭连接操作，其他的消息都直接走上行透传)

### bwserver  进程数和队列数从配置文件中获取
#### 这里上行透传路由的bwfdx断开连接重连上来的问题还需要细化思考一下   如果fd被重用了，但是客户端绑定的bwfdx没有变，会不会出现这种情况，如果出现了会不会有问题
g_bwfdx_zones[prc_id][fd]   内网fd二位数组
hash[bwfdx]                 正在使用的fdx，fd+prc_id的组合， 基于内网的连接是无状态的，即使fd短暂断开过，没有重新随机，也可以继续发送

上行透传线程->计算负载最小的bwfdx->绑定->发送到指定队列->发送协程循环发送

fork子进程->多个读写的协程->bwserver服务
                                    -> 下行，直接发送到gwrcv(入客户端的写队列)
                                    -> 上行，直接掉write函数(不入队列)
          ->一个单独发送的协程->从上行发送队列中循环pop并write
          ->一个单独accept的协程->接收新连接->初始化g_bwfdx_zones，cmd=200的入hash[bwfdx]


cid的问题，后台发过来的只有idx(connection_id)，没有ip和端口，在网关内部是否还需要保存ip和端口
    connection_id是网关创建的，ip和端口只是为了区分网关分发connection_id时需要哪个进程处理，我们这里用进程编号替代就可以了



备注：fdx:进程编号+fd
array[fdx] = {uid,cid}  每个fdx为下标的数组中存放了cid,uid两个字符串
map[gid] = list{fdx}    每个gid，存放属于这个gid的cid对应的fdx列表
map[uid] = list{fdx}    每个uid，存放属于这个uid的cid对应的fdx列表
map[cid] = list{gid}    每个cid，存放这个cid所属的gid列表
map[cid] = {fdx}        通过cid查找fd的map



## 运行环境准备 

### 1、配置文件路径
    /etc/tgg_gw/
                -->config.ini
                -->tgg_conf.ini
### 日志路径  可配置
    /var/log/tgg_gateway/
### core文件路径
    /var/corefiles/

### 服务端设置
### 单个进程大页内存个数上限，每个fd需要一个mmap，但实际需要fd*2个mmap数
sysctl -w vm.max_map_count=262144  # 提升至 26 万+
永久生效：
echo "vm.max_map_count=262144" | sudo tee -a /etc/sysctl.conf
### 允许所有内存分配请求  慎用！！！
   echo "vm.overcommit_memory=1" | sudo tee -a /etc/sysctl.conf
sudo sysctl -p
#### 解除单个进程虚拟内存总大小的上限的限制
ulimit -v unlimited  # 临时生效
永久生效：
 /etc/security/limits.conf
* soft as unlimited
* hard as unlimited


### 客户端突破端口限制
echo "net.ipv4.ip_local_port_range = 1024 60000" | sudo tee -a /etc/sysctl.conf
sudo sysctl -p
验证 sysctl net.ipv4.ip_local_port_range


问题：
1、队列长度自动配置                                                                     已完成（不够完善）
2、进程间的关系处理                                                                      30%
3、透传给gwbwprc的包丢了怎么办？尤其是关闭的包，会导致网关bw侧的hash表中残留已关闭的连接     已完成，重入trans队列，让透传重新投递
4、gwbwprc上次退出未消费的包有close的包时，要销毁这个进程所持有的客户端连接信息              已完成
5、websocket换成libwebsocket库，不再自行解析
6、json库替换                                                                          已完成
7、gwrcv进程支持多个读写协程的方案，目前的调整方案是缩短空闲等待时间(10ms->5ms)                      缩短时间会导致cpu大量空转，最好还是看能不能支持多个写的协程
8、json不能传递二进制数据的问题，能不能只传递地址不传递字符串                               已完成
9、updatesession把单个数组中多个元素转换成了多个数组，末尾还多了一个数字                    已完成
10、准入功能测试自动化                                                                    50%    
11、最后一个bw退出时，不能接入新的客户端连接，但是服务端还是会认为之前的连接有效，继续给网关发送数据

hash表rcu功能引入
GET请求\r\n\r\n查询效率问题(X86架构有更高效方式，运行有问题，先用通用方案，后续再调试)
进程管理中gwrcv无论超时多少次都不会执行sigkill，其他进程超过三次就会执行sigkill，gwrcv中存在rte_time，如果进程退出前没有结束掉，会导致后续进程卡死在rte_timer的初始化



绑核时lcore 不是按照掩码顺序绑的  掩码1234位，lcore_id是0248
安全问题：
telnet 时不会立马断开，反而会一直等待下一个包，直到超时


发布准备：开机启动脚本，服务运行前置脚本
性能测试：只需要维持websocket的基本连接和响应就可以

停掉时间同步服务，
timedatectl set-ntp FALSE



1000并发 * 5000用户

fffe0000000001250000000300000001000002011d90ad4fc34018c60b846472414ebd4122fac560054fc21c127bedbdfd4aefaef4ae6b1a10972090582608082c0ac810b8853f80a070846402418298c2c031fdfc9e5f9e3c1dad9fa6f3c9dbd972575feb9fe7af17de3ba6422210de0a8ed0a44481125016a485e1871e334884a03004462842b608694698e014225117145232323de40a6251194c2aac2484b502a9448974e1ca78029401338a18326e10341c056be3a46396cca737777b6bab2996c87bddd9e41e3ec70f307bbc84efab8bf3f5c354a952ee3a0ef5fde688aa3c67c26b5a3b2a444de34a706573544ec64882d22123a248e56ca2eb0f427fdb0fc2811fba01921dafef7a186db924e8bb819d974970fafe7bfbfaffc7be7560e9a5953f
0000008a16000000000000000000000000000000000100000000002e7b226578636c756465223a6e756c6c2c2267726f7570223a5b22{gid_hex}225d7d7b22636d64223a31372c2264617461223a223061313430383830613038306638633363653837353631303830613038306238656161656336363831383031227d

1、gwbwprc(bw侧处理进程)多核利用的问题                                               完成
2、可调式性支撑(查看当前gid,uid,cid相关hash表的情况，检查是否存在内存泄漏等问题)        
3、ip白名单，黑名单                                                                 完成   未使用，过来的流量都是nginx转发过来的，ip都是nginx服务器的ip
4、性能测试过程中发现的已知的性能问题                                                 gwrcv完成、gwbwprc待定、gwcliprc的负载均衡待设计
5、f-stack时钟问题排查(开启同步服务会导致epoll超时)


gwbwprc退出后，持有的cid对应的fd是否应释放？
和bw连接断开后，注册中心要重连，否则bw不会重连网关




时钟源问题CLOCK_REALTIME改为CLOCK_MONOTONIC进行对比，观察
偶现和bw的连接会自动断开，初步判断为多协程写时，缓冲区数据顺序紊乱了。
double free的问题