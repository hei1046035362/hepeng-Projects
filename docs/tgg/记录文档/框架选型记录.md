框架验证记录：
1、直接使用内核协议栈，使用socketpair,sendmsg,recvmsg配套可以在父子进程间传递accept的socket
2、F-Stack 中父子进程无法共享socket fd，ff_socketpair不支持，会直接报错 sendmsg: Bad file descriptor  不同的进程有自己独立的协议栈，不同的进程可以绑定同一个端口
3、大文件不走网关，通过链接走cdn，单个最大支持15Kb
4、服务端无法通过bind的socket获取ip地址




thread 创建后是否需要自己销毁


关键字段：
uid  区分用户		服务端发送消息的最小对象，可以选择排除指定的cid
gid	 区分组
cid  区分设备   	同一个uid可能在手机和电脑同时登陆    手机发送消息的时候，服务端要发送给电脑端，但是不用再发送给手机端
fd	 区分连接

uid,set<gid>

核心数据结构(全部都是共享内存)：
和fd、cid相关的都只能通过实时加入的连接添加，只有uid和gid的关系是初始化的时候能获取一次
// 通过gid找cid和uid
hash[gid,list<{fdx}>]  
// 通过uid找cid  目前服务端发送消息的都是uid而不是cid，因此需要通过uid找到cid再发送
hash[uid, list<fdx>]	 解析token时创建或更新  
// 通过cid 找uid和gid列表
// TODO  list<gid>是否为高频操作，是否不需要存在内存中，是否能使用的时候直接redis中查找
hash[cid, fdx]  通过cid找到fd,uid和所在的gid列表    对应功能   给指定网关发送 踢cid下线
hash[uid, list<gid>] 通过uid找到gid，这个关系从redis获取,在redis中的格式：list<uid, set<gid>>
// 通过fd查找fd相关的信息
array[coreid, [fd,{cid,uid,status,reserved[128]}]] 客户端fd创建时创建（数组大小暂定10W，可配置）
			  status：fd的状态：read/write/close/connected
			  
通过cid找uid
查找所有在线用户

hash表的value为list的时候，list的第一个元素不填充值，只为了保留data的位置，否则删除的时候，第一个元素删除就无法找到后续的节点


token里面有用户id
token:{"user_id":46233956298788864,"exp":1731564421,"iat":1730959621,"bot":0}

0000002d0f00000000000000000000000000000000000000000000113338393335353536393737303730303830


jthread
coroutine





进程宕机后，后台服务如何处理客户端的连接？
一个bw可以连多个gateway吗？


待行事件：
1、命名问题： rcv 改为gw,  cliprc改为route, bwserver改为bw
2、route 向下散出问题： 每个线程维护自己的gid到cid的关系，减少锁的开销
3、后续问题：观察hash,rehash的开销
4、去掉从redis读取的部分，bind时创建创建uid->cid的关系，join时创建gid->cid的关系
